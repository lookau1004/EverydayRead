{
  "cppguidelines": [
    "생각을 코드로 직접 표현하라",
    "ISO 표준 c++로 코드를 작성하라",
    "의도를 표현하라",
    "이상적으로, 프로그램은 정적 형식 안정성을 갖추어야 한다",
    "실행 시점 점검보다는 컴파일 시점 점검을 선호하라",  
    "컴파일 시점에서 점검할 수 없는 것은 실행 시점에서 점검할 수 있어야 한다",
    "실행 시점 오류는 일찍 잡아라",
    "자원이 새지 않게 하라",
    "시간이나 공간을 낭비하지 말라",
    "변경 가능 데이터보다 변경 불가 데이터를 선호하라",
    "지저분한 프로그램 요소들을 코드 전체에 흩어놓지 말고 한 곳에 캡슐화하라",
    "지원 도구들을 적절히 활용하라",
    "지원 라이브러리를 적절히 활용하라",
    "비const 전역 변수를 피하라",
    "단일체(싱글턴)를 피하라",
    "배열을 단일 포인터로 전달하지 말라",
    "안정적인 라이브러리 ABI를 원한다면 PImpl 관용구를 고려하라",
    "컴파일 시점에서 평가될 수 있는 함수는 constexpr로 선언하라",
    "함수가 예외를 던지지 않는다면 noexcept로 선언하라",
    "순수 함수를 선호하라",
    "단순하고 통상적인 방식의 정보 전달을 선호하라",
    "입력 매개변수는 복사 비용이 낮은 형식이면 값으로, 그 밖의 형식이면 참조로 전달하라",
    "전달 매개변수는 TP&&로 받고 std::forward로만 전달하라",
    "입출력 매개변수는 비const 참조로 전달하라",
    "함수가 어떤 값을 출력할 때는 출력 매개변수보다는 반환값을 선호하라",
    "여러 개의 출력값을 돌려줄 때는 구조체나 튜플을 돌려주는 방식을 선호하라",

    "위치를 나타내려면(그리고 그럴 때만) T*를 반환하라",
    "복사가 바람직하지 않으며 아무 객체도 돌려주지 않음이 필요하다면 T&를 반환하라",
    "T&&를 반환하지 마라",
    "std::move(지역객체)를 반환하지 마라",
    "main()의 반환 형식은 int이다",
    "람다는 보통의 함수로는 할 수 없는 일(지역 변수 갈무리, 지역 함수 정의)에 사용하라",
    "람다 안에서 지역적으로 쓰이는(알고리즘으로 전달하는 것도 포함해서) 데이터는 가능한 한 참조로 갈무리하라",
    "지역적으로 사용할 것이 아닌(반환하거나, 힙에 저장하거나, 다른 스레드로 전달하는 등) 데이터는 참조로 갈무리 하지 않는 것이 좋다",
    "선택할 수 있다면 중복적재보다는 기본 인수를 선호하라",
    "va_arg 인수는 사용하지 말라",
    "관련된 데이터를 구조체(structure:struct 또는 class)로 조직화하라",
    "불변식이 있는 클래스에는 class를 적용하라. 데이터 멤버들이 독릭접으로 변할 수 있으면 struct를 적용하라",
    "인터페이스와 구현의 구분을 클래스를 이용해서 표현하라",
    "클래스의 표현에 직접 접근해야 하는 함수만 멤버 함수로 만들라",
    "클래스의 보조 함수들은 그 클래스와 같은 이름공간에 배치하라",
    "하나의 문장에서 class와 enum을 정의하고 즉시 해당 형식의 변수를 선언하지 말라",
    "public이 아닌 멤버가 있다면 struct 대신 class를 사용하라",
    "멤버들을 최소한으로 노출하라",
    "클래스 위계구조보다 구체 형식들을 선호하라",
    "구체 형식은 정규 형식으로 작성하라",
    "가능하면 기본 연산은 아예 정의하지 말라",
    "기본 연산을 하나라도 정의하거나 =delete로 삭제했다면, 다른 모든 기본 연산도 정의하거나 삭제하라",
    "기본 연산들의 일관성을 유지하라",
    "생성자는 완전하게 초기화된 객체를 생성해야 한다",
    "생성자에서 유효한 객체를 생성할 수 없으면 예외를 던져라",
    "복사 가능(값 형식) 클래스에는 반드시 기본 생성자가 있어야 한다",
    "데이터 멤버들을 초기화하기만 하는 기본 생성자는 정의하지 말고, 대신 멤버 초기화 구문을 사용하라",

    "기본적으로, 단일 인수 생성자는 explicit로 선언하라",
    "멤버 변수들을 멤버 선언 순으로 정의하고 초기화하라",
    "생성자에서 멤버를 상수로 초기화할 때 멤버 초기화 구문보다는 클래스 안 초기화 구문을 선호하라",
    "생성자 안의 배정보다는 멤버 초기화 구문을 선호하라",
    "한 클래스의 모든 생성자에 공통인 작업들은 위임 생성자로 표현하라",
    "더 이상의 명시적 초기화가 필요하지 않은 파생 클래스에 기반 클래스의 생성자를 도입할 때는 상송 생성자를 사용하라",
    "다형적 클래스는 복사를 금지해야 한다",
    "객체가 파괴될 때 어떤 작업을 명시적으로 수행해야 하는 클래스에는 소멸자를 정의하라",
    "클래스가 획득한 모든 자원은 반드시 클래스의 소멸자에서 해제해야 한다",
    "클래스에 원시 포인터(T*)나 참조(T&) 멤버가 있으면, 그 멤버가 자원을 소유하는지 따져 봐야 한다",
    "클래스에 다른 객체를 소유하는 포인터 멤버가 있으면 소멸자를 정의하라",
    "기반 클래스의 소멸자는 public과 vitual의 조합이거나 protected와 비 vitual의 조합이어야 한다",
    "만일 기본 의미론이 적용됨을 명시적으로 밝혀야 한다면 =default를 사용하라",
    "기본 행동 방식을 비활성화하려면 =delete를 사용하라 (다른 방법 대신)",
    "생성자와 소멸자에서는 가상 함수를 호출하지 말라",
    "==를 피연산자 형식들에 대칭으로 작성하고 noexcept로 선언하라",
    "기반 클래스들에 대한 ==를 조심하라",
    "클래스 위계구조는 위계적인 구조가 자연스러운 개념들을 표현하는 용도로(만) 사용하라",
    "인터페이스로 사용할 기반 클래스는 추상 클래스로 만들어라",
    "인터페이스와 구현을 완전하게 분리해야 할 때는 추상 클래스를 인터페이스로 사용하라",
    "보통의 경우 추상 클래스에는 생성자가 필요 없다",
    "가상 함수에는 virtual, override, final 중 딱 하나만 지정해야 한다",
    "다형적 클래스에 깊은 복사를 적용할 때는 복사 생성/배정보다 가상 clone 함수를 선호하라",
    "이유 없이 함수를 virtual로 만들지는 말라",
    "자명한 조회 함수와 설정 함수를 피하라",
    "protected 데이터를 피하라"
    
  ]
}